1.withgear
import ch.aplu.robotsim.*;
public class withgear
{
public withgear()
{
LegoRobot robot = new LegoRobot();
Gear gear = new Gear();

robot.addPart(gear);
gear.setSpeed(20);
gear.forward();
Tools.delay(2000);      
gear.left(2000);
gear.forward(2000);
gear.leftArc(0.2,2000);
gear.forward(2000);
gear.leftArc(-0.2,2000);
gear.right(2000);

robot.exit();
  }
  public static void main(String[] args) {
     new withgear();
  }
  }
2.withoutgear
import ch.aplu.robotsim.*;
class withoutgear
{
      withoutgear()
      {
      TurtleRobot robot = new TurtleRobot();
      robot.forward(100);
      robot.left(90);
      robot.forward(50);
      robot.right(90);
      robot.forward(50);
      
      robot.exit();  
      }  
      public static void main(String[] args)
       {
       new withoutgear();
      }  
                
}
 3.2motors ,leftright forward
import ch.aplu.robotsim.*;
public class pract3
{
public pract3()
{

LegoRobot robot = new LegoRobot();
Motor motA = new Motor(MotorPort.A);
Motor motB = new Motor(MotorPort.B);
robot.addPart(motA);
robot.addPart(motB);

System.out.println("MotA forward , motB Forward ");
motA.forward();
motB.forward();
Tools.delay(2000);



System.out.println("motA stop");
motA.stop();
Tools.delay(2000);

System.out.println("motB stop"); 
motB.stop();
Tools.delay(2000);

System.out.println("motA forward , motB backward");
motA.backward();
motB.forward();
Tools.delay(2000);

System.out.println("motA backward");
motA.backward();    
Tools.delay(2000);
System.out.println("existing");
robot.exit();

  }
public static void main(String[] args) {
new pract3();
  
}  

static
{
RobotContext.showStatusBar(30);
}
  } 

Pract 4-Square wgile loop
import ch.aplu.robotsim.*;
public class square
{
square()
{
TurtleRobot robot = new TurtleRobot();
int i = 0;
while (i < 4)
{
robot.forward(50);
robot.right(90);
i++;
}
robot.exit();
 } // end of while
public static void main(String[] args) {
       new square();
}
  }
pract 5- steps for loop
import ch.aplu.robotsim.*;
class steps 
{
steps()
{
  
 TurtleRobot Robot = new TurtleRobot();
 for (int i=0;i<4;i++ ) 
 {
  Robot.forward(20);
  Robot.right(90);
  Robot.forward(20);
  Robot.left(90);
  
} // end of for
Robot.exit();
}
public static void main(String[] args)
{
new steps();
  }

  }
pract-6  1. random move
//Random moves 
import ch.aplu.robotsim.*;
public class  RandomMove
{
  RandomMove()
  {
    TurtleRobot robot = new TurtleRobot();
    for(int i=0; i<7 ; i++)
    {
      double a = Math.random();
      if(a < 0.5)
        robot.right(90);
      else 
        robot.left(90);
      robot.forward(100);   
      
    }
    robot.exit();
  }
  public static void main(String[] args)
  {
    new RandomMove();
  }
  
}
 2.Controlling codition switch case

import ch.aplu.robotsim.*;
  public class SpeedSwitch
  {
  SpeedSwitch()
  {
  TurtleRobot robot = new TurtleRobot();
  for(int k =1; k < 6 ; k++)
  {
  int speed;
      switch (k) 
      {
        case  1:
            speed=20 ;
          break;
        case  2:
             speed =40;
            break;
        case 3:
          speed=60;
          break;
        case 4:
          speed=80;
          break;
        default: 
                speed=50;
      } // end of switch
      System.out.println("k = " + k + " → Speed = " + speed);
      robot.setTurtleSpeed(speed);
      robot.forward(200);
      robot.right(90);
    }
    robot.exit();
 }   
  public static void main(String[] args)
  {
  new SpeedSwitch();
    }
    }




7. robot follows a line :
import ch.aplu.robotsim.*;
import ch.aplu.jgamegrid.*;
import java.awt.*;

public class followln implements LightListener
{
private Gear gear = new Gear();
public followln()
{
LegoRobot robot = new LegoRobot();
LightSensor ls = new LightSensor(SensorPort.S3);
robot.addPart(gear);
robot.addPart(ls);
ls.addLightListener(this,500);
gear.forward();
}
public void bright(SensorPort port , int level)
{
gear.rightArc(0.15);
   }
public void dark(SensorPort port , int level)
{
gear.leftArc(0.15);
   }
public static void main(String[] args)
{
new followln();
} 
public static void _init(GameGrid gg)
{
 GGBackground bg= gg.getBg();
 bg.setPaintColor(Color.blue);
 bg.fillArc(new Point(250,250),50,0,360);
 bg.fillArc(new Point(250,350),100 , 0, 360);
  }
}
8.CircleMotor :
import ch.aplu.robotsim.*;
public class circlemotor
{
circlemotor()
{
LegoRobot robot = new LegoRobot();
Motor motA= new Motor(MotorPort.A);
Motor motB= new Motor(MotorPort.B);
robot.addPart(motA);
robot.addPart(motB);
motA.setSpeed(60);
motB.setSpeed(30);
while (true) {
motA.forward();
motB.forward(); 
} // end of while
}
public static void main(String[] args ) {
      new circlemotor();
}
}


pract 9 -path follow
import ch.aplu.robotsim.*;
import ch.aplu.util.*;

public class pathfind
{
 pathfind()
{
 LegoRobot robot = new LegoRobot();
 Gear gear= new Gear();
 robot.addPart(gear);
 TouchSensor ts1 = new TouchSensor(SensorPort.S3);
 TouchSensor ts2 = new TouchSensor(SensorPort.S3);
 robot.addPart(ts1);
 robot.addPart(ts2);
 gear.forward();
 while (!QuitPane.quit()) { 
 boolean t1=ts1.isPressed();
 boolean t2=ts2.isPressed();
 if (t1 && t2) {
    gear.backward(500);
    gear.left(1200);
    gear.forward();
 } // end of if
 else {
 if (t1) 
 {
    gear.backward(500);
    gear.left(400);
    gear.forward();  
 } 
 else {
 if (t2) {
     gear.backward(500);
    gear.left(100);
    gear.forward();
 } // end of if
  
 } // end of if-else
    } 
    Tools.delay(20);
 } // end of while
 robot.exit();
  }
  
  
public static void main(String[] args)
{
    new pathfind();
  }
  static{
       RobotContext.setLocation(10,10);
       RobotContext.setStartDirection(5);
       RobotContext.setStartPosition(100,240);
       RobotContext.useObstacle(RobotContext.channel);
    
    }
    
  }
  
pract 10 - register obstacle
 import ch.aplu.robotsim.*;
import ch.aplu.jgamegrid.*;
import java.awt.*;

public class regobst
{
  public regobst ()
  {
    LegoRobot robot = new LegoRobot();
    Gear gear = new Gear();
    TouchSensor ts = new TouchSensor(SensorPort.S3);
    robot.addPart(gear);
    robot.addPart(ts);
    gear.setSpeed(30);
    gear.forward();
    while (true)
    {
      if (ts.isPressed())
      {
        gear.backward(1200);
        gear.left(750);
        gear.forward();
      }
    }
  }

  public static void main(String[] args)
  {
    new regobst ();
  }



  private static GGBitmap bar(int width, int length, Color color)
  
  {
    GGBitmap bm = new GGBitmap(width, length);
    bm.setPaintColor(color);
    bm.fillRectangle(new Point(0, 0), new Point(width - 1, length - 1));
    return bm;
  }

  private static GGBitmap circle(int radius,  Color color)
  {
    GGBitmap bm = new GGBitmap(2 * radius, 2 * radius);
    bm.setPaintColor(color);
    bm.setLineWidth(3);
    bm.drawCircle(new Point(radius, radius), radius - 1);
    return bm;
  }

  static
  {
    RobotContext.setStartPosition(300, 200);
    RobotContext.setStartDirection(30);
    RobotContext.showNavigationBar();
    RobotContext.useObstacle(bar(300, 20, Color.red), 250, 150);
    RobotContext.useObstacle(bar(300, 20, Color.green), 250, 350);
    RobotContext.useObstacle(bar(20, 300, Color.blue), 150, 250);
    RobotContext.useObstacle(bar(20, 300, Color.yellow), 350, 250);
    RobotContext.useObstacle(circle(20, Color.black), 250, 250);
  }
}



//------------------A----
1.RodCutting
def cutRod(prices, n):
    if n == 0:
        return 0
     max_value = 0
    for length in range(1, n + 1):
        value = prices[length - 1] + cutRod(prices, n - length)
        max_value = max(max_value, value)   
    return max_value
arr = [1, 5, 8, 9, 10, 17, 17, 20]
size = len(arr)
print("The Array:", arr)
print("Rod Size:", size)
print("Maximum Obtainable Value is:", cutRod(arr, size))

2.merge sort :

def mergesort(lst):
    if len(lst) > 1:
        mid = len(lst) // 2
        left = lst[:mid]
        right = lst[mid:]
        mergesort(left)
        mergesort(right)
        i = j = k = 0
        while i < len(left) and j < len(right):
            if left[i] < right[j]:
                lst[k] = left[i]
                i += 1
            else:
                lst[k] = right[j]
                j += 1
            k += 1
        while i < len(left):
            lst[k] = left[i]
            i += 1
            k += 1
        while j < len(right):
            lst[k] = right[j]
            j += 1
            k += 1
num = int(input("How many elements you want in list: "))
lst = [int(input("Enter element: ")) for _ in range(num)]

mergesort(lst)
print("Sorted list is:", lst)

3.krushkals
def find(parent, v):
    if parent[v] != v:
        parent[v] = find(parent, parent[v])
    return parent[v]

def union(parent, rank, a, b):
    rootA = find(parent, a)
    rootB = find(parent, b)

    if rootA != rootB:
        if rank[rootA] < rank[rootB]:
            parent[rootA] = rootB
        elif rank[rootA] > rank[rootB]:
            parent[rootB] = rootA
        else:
            parent[rootB] = rootA
            rank[rootA] += 1

def kruskal(edges, V):
    edges.sort(key=lambda x: x[2])
    parent = [i for i in range(V)]
    rank = [0] * V
    mst = []

    for u, v, w in edges:
        if find(parent, u) != find(parent, v):
            mst.append((u, v, w))
            union(parent, rank, u, v)

    return mst

edges = [
    (0, 1, 10),
    (0, 2, 6),
    (0, 3, 5),
    (1, 3, 15),
    (2, 3, 4)
]

result = kruskal(edges, 4)

print("Minimum Spanning Tree:")
for u, v, w in result:
    print(u, "-", v, ":", w)

#4. Djkshtra 
import heapq

def add_edge(graph, u, v, w):
    graph.setdefault(u, []).append((v, w))

def dijkstra(graph, start):
    dist = {node: float('inf') for node in graph}
    dist[start] = 0
    pq = [(0, start)]

    while pq:
        d, node = heapq.heappop(pq)

        if d > dist[node]:
            continue
        
        for neigh, w in graph.get(node, []):
            new_d = d + w
            if new_d < dist.get(neigh, float('inf')):
                dist[neigh] = new_d
                heapq.heappush(pq, (new_d, neigh))
    return dist


# --------- Graph Creation ----------
graph = {}
add_edge(graph, 'A', 'B', 4)
add_edge(graph, 'A', 'C', 2)
add_edge(graph, 'B', 'C', 5)
add_edge(graph, 'B', 'D', 10)
add_edge(graph, 'C', 'D', 3)
add_edge(graph, 'D', 'E', 7)
add_edge(graph, 'E', 'F', 2)
add_edge(graph, 'F', 'D', 2)

# Run Dijkstra
start = 'A'
result = dijkstra(graph, start)

# Output
for node, d in result.items():
    print(f"{start} → {node} = {d}")

#Strassen Matrix 
def split_matrix(matrix):
    n = len(matrix)
    mid = n // 2
    A = [row[:mid] for row in matrix[:mid]]
    B = [row[mid:] for row in matrix[:mid]]
    C = [row[:mid] for row in matrix[mid:]]
    D = [row[mid:] for row in matrix[mid:]]
    return A, B, C, D

def add_matrix(m1, m2):
    return [[m1[i][j] + m2[i][j] for j in range(len(m1[0]))] for i in range(len(m1))]

def subtract_matrix(m1, m2):
    return [[m1[i][j] - m2[i][j] for j in range(len(m1[0]))] for i in range(len(m1))]

def strassen_multiply(m1, m2):
    if len(m1) == 1:
        return [[m1[0][0] * m2[0][0]]]

    A, B, C, D = split_matrix(m1)
    E, F, G, H = split_matrix(m2)

    P1 = strassen_multiply(A, subtract_matrix(F, H))
    P2 = strassen_multiply(add_matrix(A, B), H)
    P3 = strassen_multiply(add_matrix(C, D), E)
    P4 = strassen_multiply(D, subtract_matrix(G, E))
    P5 = strassen_multiply(add_matrix(A, D), add_matrix(E, H))
    P6 = strassen_multiply(subtract_matrix(B, D), add_matrix(G, H))
    P7 = strassen_multiply(subtract_matrix(A, C), add_matrix(E, F))

    n = len(m1)
    result = [[0 for _ in range(n)] for _ in range(n)]
    k = n // 2

    for i in range(k):
        for j in range(k):
            result[i][j] = P5[i][j] + P4[i][j] - P2[i][j] + P6[i][j]
            result[i][j + k] = P1[i][j] + P2[i][j]
            result[i + k][j] = P3[i][j] + P4[i][j]
            result[i + k][j + k] = P5[i][j] + P1[i][j] - P3[i][j] - P7[i][j]

    return result

matrix1 = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
    [13, 14, 15, 16]
]

matrix2 = [
    [17, 18, 19, 20],
    [21, 22, 23, 24],
    [25, 26, 27, 28],
    [29, 30, 31, 32]
]

result_matrix = strassen_multiply(matrix1, matrix2)

for row in result_matrix:
    print(row)

#Bubble
a.	Bubble Sort :

    def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr
arr = [64, 34, 25, 12, 22, 11, 90]
print("Original array:", arr)
sorted_arr = bubble_sort(arr)
print("Sorted array:", sorted_arr)  

#
#b.Selection Sort :
 def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_idx = i
        for j in range(i + 1, n):
    if arr[min_idx] > arr[j]:
                min_idx = j

        arr[i], arr[min_idx] = arr[min_idx], arr[i]
    return arr
arr = [64, 25, 12, 22, 11]
print("The sorted array:")
print(selection_sort(arr))
 
#C.Insertion Sort :
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j] 
            j -= 1
        arr[j + 1] = key  
    return arr
arr = [5, 2, 4, 6, 1, 3]
print("The sorted array:")
print(insertion_sort(arr))


# Lcs 

def lcs(X, Y, m, n):
    L = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if X[i - 1] == Y[j - 1]:
                L[i][j] = L[i - 1][j - 1] + 1
            else:
                L[i][j] = max(L[i - 1][j], L[i][j - 1])

    index = L[m][n]
    lcs_seq = [""] * index
    i, j = m, n

    while i > 0 and j > 0:
        if X[i - 1] == Y[j - 1]:
            lcs_seq[index - 1] = X[i - 1]
            i -= 1
            j -= 1
            index -= 1
        elif L[i - 1][j] > L[i][j - 1]:
            i -= 1
        else:
            j -= 1

    print("LCS is:", "".join(lcs_seq))
    return L[m][n]

X = input("Enter first string: ")
Y = input("Enter second string: ")
m, n = len(X), len(Y)
length = lcs(X, Y, m, n)
print("Length of LCS is:", length)



#permute by sorting
import random

def permute_by_sorting(arr):
    keys = [random.random() for _ in arr]
    paired = list(zip(keys, arr))
    paired.sort()
    return [value for (_, value) in paired]

original = [1, 2, 3, 4, 5]
print("Original:", original)
print("Permuted (sorting):", permute_by_sorting(original))

#Permute by Cycling 
import random
def permute_by_cyclic(arr):
    arr = arr[:]  
    n = len(arr)
    for i in range(n):
        j = random.randint(i, n - 1)
        arr[i], arr[j] = arr[j], arr[i]
    return arr

original = [1, 2, 3, 4, 5]
print("Original:", original)
print("Permuted (cyclic):", permute_by_cyclic(original))

#extended eculidean algo
def extended_euclidean_algorithm(a, b):
    if b == 0:
        return a, 1, 0
    gcd, x1, y1 = extended_euclidean_algorithm(b, a % b)
    x = y1
    y = x1 - (a // b) * y1
    return gcd, x, y

def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

num1 = 48
print('Number 1 :', num1)
num2 = 18
print('Number 2 :', num2)

# Calculate GCD using Euclid's algorithm
result_gcd = gcd(num1, num2)
print(f"GCD of {num1} and {num2} using Euclid's algorithm: {result_gcd}")

# Calculate GCD and x, y using extended Euclidean algorithm
gcd_value, x, y = extended_euclidean_algorithm(num1, num2)
print(f"GCD of {num1} and {num2} using extended Euclidean algorithm: {gcd_value}")
print(f"x and y values such that {gcd_value} = {num1} * {x} + {num2} * {y}")


#euclids theorem:
def euclids_theorem(p, a):
    def is_prime(n):
        if n <= 1:
            return False
        for i in range(2, int(n**0.5) + 1):
            if n % i == 0:
                return False
        return True
    if not is_prime(p) or p == a:
        return f"{p} is not a prime number or invalid input."
    import math
    if math.gcd(a, p) == 1:
        return f"Euclid's theorem verified: {p} does not divide {a}, gcd({a}, {p}) = 1"
    else:
        return f"Euclid's theorem NOT verified: gcd({a}, {p}) ≠ 1"

# Example
p_value = 17
a_value = 8
result = euclids_theorem(p_value, a_value)
print(result)


#fermat theorem :
def mod_exp(a, b, m):
    r = 1
    while b > 0:
        if b % 2 == 1:
            r = (r * a) % m
        a = (a * a) % m
        b //= 2
    return r

def fermat_theorem(p, a):
    if p > 1 and a % p != 0:
        if mod_exp(a, p-1, p) == 1:
            return "Fermat verified"
    return "Not verified"

print(fermat_theorem(7, 3))


#greedyset cover
def greedy_cover(U, S):
    U = set(U)
    result = []
    while U:
        best = max(S, key=lambda s: len(U & s))
        if not (U & best):
            break
        result.append(best)
        U -= best
    return result

U = {1,2,3,4,5,6,7,8,9,10}
S = [{1,2,3,4,5}, {2,5,7,8}, {1,4,6,9}, {3,6,9,10}]

for s in greedy_cover(U, S):
    print(s)

#floydd Warshall
def floydWarshall(dist):
    V = len(dist)
    for k in range(V):
        for i in range(V):
            for j in range(V):
                if dist[i][k] != INF and dist[k][j] != INF:
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])

INF = 100000000
dist = [
    [0, 4, INF, 5, INF],
    [INF, 0, 1, INF, 6],
    [2, INF, 0, 3, INF],
    [INF, INF, 1, 0, 2],
    [1, INF, INF, 4, 0]
]

floydWarshall(dist)

print("Shortest distance matrix using Floyd–Warshall:")
for i in range(len(dist)):
    for j in range(len(dist)):
        if dist[i][j] == INF:
            print("INF", end=" ")
        else:
            print(dist[i][j], end=" ")
    print()
